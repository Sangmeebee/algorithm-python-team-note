# Dynamic Programming

- 동적 계획법 : 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상
- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역(리스트 or 배열)에 저장하여 다시 계산하지 않도록 한다.
- 점화식 찾기!
- 이런 경우 사용한다!  ex) 피보나치 수열
  - **최적 부분 구조**
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
  - **중복되는 부분 문제**
    - 동일한 작은 문제를 반복적으로 해결
- 구현 방법
  - 탑다운 : 큰 문제를 해결하기 위해 작은 문제들을 재귀적으로 호출 
    - 재귀 이용
    - 한번 계산된 결과를 캐싱하기 위해 메모이제이션 기법 사용
    - 메모이제이션 : 한번 계산한 결과를 메모리 공간에 메모하는 기법
      - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
  - 보텀업 : 아래쪽에서 작은문제를 해결해 나가면서, 먼저 계산했던 문제의 값을 활용해 다음 문제까지 차례대로 해결
    - 반복문 이용
    - **DP 테이블** : 결과 저장용 리스트



### 피보나치 수열을 재귀적으로 코딩했을 때의 문제

<img src="/Users/sangmee/Library/Application Support/typora-user-images/스크린샷 2021-02-08 오후 5.43.23.png" alt="스크린샷 2021-02-08 오후 5.43.23" style="zoom:50%;" />

같은 계산을 여러번 반복 수행하여 효율성이 떨어진다. O(2^N)



### 피보나치 수열을 탑다운으로 구현 (O(N))

~~~python
d = [0]*100

def fibo(x) :
  if x == 1 or x == 2 :
    return 1
  if d[x] != 0 :
    return d[x]
  d[x] = fibo(x-2)+fibo(x-1)
  return d[x]
print(fibo(99))
~~~



### 피보나치 수열을 보텀업으로 구현 (O(N))

~~~python
d = [0]*100
d[1] = 1
d[2] = 1
n = 99
for i in range(3, n+1) :
  d[i] = d[i-2] + d[i-1]
print(d[99])
~~~



### 다이나믹 프로그래밍 VS 분할 정복(퀵 정렬)

- 공통점 : 최적 부분 구조를 갖는다.
- 차이점 : 다이나믹 프로그래밍은 부분 문제의 중복이 되어야한다. (점화식의 중복)



## 중요) 가장 긴 증가하는 부분 수열(LIS) : 동적 계획법 자주 출제 문제

- array = {4, 2, 5, 8, 4, 11, 15}  의 LIS는 {4 ,5, 8, 11, 15} 이다.

- D[i] = (array[i] 를 마지막 원소로 가지는 부분 수열의 최대 길이)

- 모든 0 <= j < i 에 대하여   (i 보다 앞쪽에 있는 j를 모두 확인하면서)

- D[i] = max(D[i], D[j] + 1) if array[j] < array[i]

  ~~~python
  # n = 수열 갯수
  # array = 수열
  
  dp = [1]*n # 부분 수열의 최대길이를 전부 1로 세팅
  for i in range(1, n) :
    for j in range(i) :
      if array[i] > array[j] :
        dp[i] = max(dp[j]+1, dp[i])
  ~~~




##  최장 공통 부분 수열(LCS)

- 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제

- ACAYKP와 CAPCAK의 LCS는 ACAK

- ```
  만약, 비교하는 위치의 문자가 서로 같으면 
      현재 위치의 값 = 왼쪽 대각선 값 + 1  (배열 범위를 벗어났으면 0이라고 가정 )
  다르다면  
      현재 위치의 값 = MAX{왼쪽 값, 위쪽 값}   
  ```

- ~~~python
  a = list(input())
  b = list(input())
  alen = len(a)
  blen = len(b)
  dp = [[0] * (alen + 1) for _ in range(blen + 1)]
  
  for i in range(1, blen + 1):
      for j in range(1, alen + 1):
        	# 같은 글자면 왼쪽 대각선 값 +1
          if a[j - 1] == b[i - 1]:
              dp[i][j] = dp[i - 1][j - 1] + 1
          # 다른 글자면, 위와 왼쪽 중 큰 값을 가져온다.
          else:
              dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
  
  print(dp[blen][alen])
  
  ~~~

## Tip

- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 답이 큰 문제에서 그대로 사용될 수 있으면 동적계획법으로 코드를 개선